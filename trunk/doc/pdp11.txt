






			 О П И С А Н И Е

	 СИСТЕМЫ КОМАНД PDP11 - СОВМЕСТИМЫХ КОМПЬЮТЕРОВ


			*	*	*


		DESCRIPTION OF THE PDP11 COMMANDS


		Обозначения в тексте:
	*   -0 для слов, 1 для байт
	ss  -поле источника (6 бит)
	dd  -поле приемника (6 бит)
	R   -регистр общего назначения (3 бита)
	xx  -смещение (8 бит), +127 .. -128
	n   -цифра (3 бита)
	M   -маска (4 бита)
	nn  -число(6 бит)
	\   -резервный/неизвестный код
	eis -EIS инструкция
	fis -FIS инструкция
	fpu -FPU инструкция
	cis -CIS инструкция
	src -операнд - источник
	dst -операнд - приемник
	offset - смещение
	CC  -коды условий (биты в слове состояния процессора)
	PC=R7=регистр - счетчик команд
	SP=R6=регистр - указатель стека
	PSW - слово состояния процессора
	?   -код транслируется на MACRO-11 [61], оисание не найдено
	::  -каждое двоеточие-произвольная (восьмиричная) цифра
	mmg -инструкция диспетчера памяти
	si  -специальная инструкция: уникальна для указанного процессора
	Установки кодов условий:
	-   -не изменяется
	1   -всегда устанавливается в 1
	0   -всегда очищается
	*   -устанавливается/чистится в соответствии с общими правилами:
	     N -устанавливается, если старший бит результата установлен,
		иначе чистится;
	     Z -устанавливается при нулевом результате, иначе чистится;
	     V -устанавливается при арифметическом переполнении, иначе 
		чистится;
	     C -устанавливается при ереносе из старшего разряда, иначе 
		очищается;
	+   -действия над битом - в оисании конкретной инструкции.

	Last correction : Date 06/02/90  Time 01:42:08


op.	op.    instr.  PSW(CC)
code	name	set	NZVC	description

000000	HALT		----	Выводит  процессор  из   активного    режима:
				прерывается   выполнение    команд    текущей
				программы,  PC  указывает  на  следующую   за
				прерванной  команду,  PC   отображается    на
				консоли, разрешена работа консоли. На  разных
				процессорах реализована различно:1801ВМ1,2,3,
				1811  переводит  в  программу    обслуживания
				останова. 
				Для    1801ВМ1     (177716)<-000010!(177716),
				(177676)<-(PSW),(177674)<-(PC),(PC)<-(160002)
				(PSW)<-(160004);
				Для ВМ2 в  пользовательском  режиме  вызывает
				прерывание в моду HALT по  вектору  останова,
				то же в моде HALT при разрешенном  HALT,  при
				запрещенных выполняется  как  NOP.  В  других
				процессорах: если нет  диспетчера  памяти,  и
				процессор  соответствует  старым   стандартам
				DEC, процессор останавливается, и  может быть
				перезапущен  с  точки  останова,    либо    с
				набранного  с   пульта    адреса    пультовым
				переключателем; если есть  диспетчер  памяти,
				и команда выполнялась не в  моде  KERNEL,  то
				происходит  прерывание  и  переход  в    моду
				KERNEL  по  резервной  инструкции;  в    моде
				KERNEL останавливает процессор,  если  он  не
				1801/06 ВМ3.  Для  них  HALT  в  моде  KERNEL
				переводит  процессор  в  моду   HALT:    стек
				пультовой моды устанавливется с адреса 100000
				далее  в  этот  стек  заносятся   PC,    PSW;
				загружает  PSW  константой   340,    включает
				диспетчер памяти на преобразование адресов  в
				22-разрядные и стартует с адреса 0 пультового
				ОЗУ (скрытого от пользователя).

000001	WAIT		----	Инструкция  ожидания  прерывания.   Процессор
				останавливается  и   освобождает    системную
				магистраль  до  первого    незамаскированного

				прерывания.  PC  указывает  на  следующую  за
				WAIT команду. После  возврата  из  прерывания
				выполнение    программы    продолжается    со
				следующей за WAIT команды.

000002	RTI		++++	Возврат  из  прерывания.PC<-(SP)+,PSW<-(SP)+,
				грузит все  доступные  биты  слова  состояния
				из стека:
				для 1801ВМ2 бит  H  грузится  только  в  моде
				HALT и позволяет  выходить  из  HALT  в  USER

000003	BPT		++++	Отладочное  прерывание    по    14    ячейке.
				-(SP)<-PSW,  -(SP)<-PC,  PC<-(14),  PSW<-(16)
				n,z,v,c: загружаются из вектора прерывания

000004	IOT		++++	Программное  прерывание  ввода-вывода  по  20
				ячейке.  -(SP)<-PSW,  -(SP)<-PC,    PC<-(20),
				PSW<-(22);  n,z,v,c:  грузятся  из    вектора
				прерывания; команда  применяется  для  вызова
				процедуры ввода-вывода IOX  в  перфоленточной
				операционной системе и для регистрации ошибок
				в дисковой оерационной системе.

000005	RESET		----	Сброс  внешних    устройств.    Процессорами,
				имеющими    диспетчер    памяти,    в    моде
				USER  /  SUPERVISOR  исполняется  как    NOP.
				Выставляет сигнал  сброса  внешних  устройств
				на магистраль. Время  выполнения  зависит  от
				типа процессора  и  его  тактовой  частоты.

000006	RTT	eis	++++	Аналогична RTI, но при установленном  бите  T
				в PSW прерывание после нее  не  возникает  до
				окончания  следующей  команды.

000007	MFPT	?		чтение модели процессора

000010	START	si	++++	1801ВМ2  в  обычном  режиме  TRAP  TO  10,  в
000011	START	si		halt  -  режиме  PC<-PC',PSW(8-0)<-PSW'(8-0),
000013	START	si		если  нет  IRQ,  начинает  грузить  коды    и
				выполнять их. Используется  для  переключения
				HALT->USER.

000012	START	si		То  же для 1801ВМ2, аналогичные по назначению
				действия для 1801ВМ1:(177716)<-177767&(177716)
				(PC)<-(177674),	(PSW)<-(177676)

000014	STEP	si	----	1801ВМ2  в  обычном  режиме  TRAP  TO  10,  в
000015	STEP	si		halt - режиме  PC<-PC',  PSW(8-0)<-PSW'(8-0),
000017	STEP	si		безусловно  передает    управление    команде
				по новому PC,затем обслуживаются  прерывания,
				внешний и командный HALT в том числе.
000016	STEP	si		То же  для 1801ВМ2, аналогичные по назначению
				действия для 1801ВМ1:(177716)<-177767&(177716)
				(PC)<-(177674), (PSW)<-(177676)
		
000020	RD	si	**--	1801ВМ2 безадресное чтение (особый  обмен  по
				магистрали,  не  требует  ответа    RPLY    )
				R0<-(SEL) только в пультовом режиме

000021	URD	si	**--	1801ВМ2  читает  слово из  пространства USER: 
				R0<-(R5)+ только в halt- режиме.

000022	RDPC	si	**--	1801ВМ2 чтение  копии PC: R0<-PC',  только  в
000023	RDPC	si		пультовом режиме.

000024	RDPS	si	**--	1801ВМ2 чтение копии PSW: R0<-PSW', только  в
000025	RDPS	si		пультовом режиме
000026	RDPS	si
000027	RDPS	si

000030	RD	si	**--	1801ВМ2  безадресное  чтение  аналогично коду
				000020

000031	UWR	si	**--	1801ВМ2 запись в адресное  пространство USER:
				R0-> -(R5) только в пультовом режиме.

000032	WRPC	si	**--	1801ВМ2 запись в копию PC: R0->PC', только  в
000033	WRPC	si		пультовом режиме.

000034	WRPS	si	++++	1801ВМ2 запись в копию PSW: R0->PSW',  только 
000035	WRPS	si	****	в пультовом режиме
000036	WRPS	si
000037	WRPS	si


00004:		\
00005:		\
00006:		\
00007:		\

0001dd	JMP		----
				Переход. Грузит PC  из  источника,  используя
				адресацию  dd.  Код  адресации  0    (попытка
				выполнить  команду,  записанную  в   регистре
				общего  назначения)  на  большинстве    типов
				процессоров приводит к TRAP TO  4;  PC<-(dst)

00020R	RTS		----	Возврат  из  подпрограммы. PC <- R, R <- (SP)

00021R		si	----	LSI-11: инструкция извлечения пяти внутренних
				16-разрядных    регистров:       (R)<-(R)+12;
				содержимое  извлеченных   ячеек:
				(R): RBA  -  регистр  адреса  шины.  Содержит
				последний адрес шины, использованный  не  для
				извлечения инструкции, а для режимов  адреса-
				ции операнда назначения 3,5,6,7; 
				(R)+2: RSRC  -  регистр  исходного  операнда,
				содержит    последний    исходный     операнд
				двухоперандной   инструкции.    При    режиме
				адресации источника 0 старший байт может быть
				неверным;
				(R)+4: RDST - регистр операнда  назначения  -
				содержит  последний    операнд    назначения,
				извлеченный процессором;
				(R)+6: RPSW - старшие 4 бита  -  копия  битов
				4 - 7 слова состояния процессора,  остальные-
				мусор;
				(R)+10: RIR - регистр инструкции  -  содержит
				текущую, а не  предыдущую  инструкцию,  имеет
				формат  36R  из-за  особенностей   микрокода.

00022n		si	----	LSI-11: передает микропрограммное  управление
				микроячейке 3000; если такой микроячейки нет,
				прерывание по резервной инструкции.


00023n	SPL	mmg	----	Установить  приоритет  процессора.  Только  в
				моде  KERNEL:  PSW(5-7)<-n;  в  модах   USER,
				SUPERVISOR исполняется как NOP.

000240	NOP		----	Ничего не делает, точнее чистит никакие  биты
				условий в PSW (M=0, см. след. команду).

00024M	CL<NZVC>	++++	чистит  биты  PSW(N,Z,V,C)  по  маске  из   4
				младших битов кода команды.
000241	(CLN)			(M=^B1000)
000242	(CLZ)			(M=^B0100)
000244	(CLV)			(M=^B0010)
000250	(CLC)			(M=^B0001)
000257	(CCC)			(M=^B1111)

000260	NOP'		----	нигде не упоминается, ничего  содержательного
				не делает, от кода 000240 отличается лишь тем,
				что устанавливает никакие биты  условий в PSW
				(M=0, см. след. команду).

00026M	SE<NZVC>	++++	устанавливает биты PSW(N,Z,V,C) по маске из 4
				младших битов кода команды.
000261	(SEN)			(M=^B1000)
000262	(SEZ)			(M=^B0100)
000264	(SEV)			(M=^B0010)
000270	(SEC)			(M=^B0001)
000277	(SCC)			(M=^B1111)

0003dd	SWAB		++00	обмен байтов в слове:byte1/byte0<-byte0/byte1
				n,z  устанавливаютсся  по   младшему    байту
				результата

0004xx	BR		----	переход безусловный. Смещение xx автоматичес-
				ки умножается на 2,  и  складываnется  с  PC:
				PC<-PC+(2*offset)

0010xx	BNE		----	переход по не нулю:  PC<-PC+(2*offset) if z=0

0014xx	BEQ		----	переход по нулю:     PC<-PC+(2*offset) if z=1


0020xx	BGE		----	переход по больше или равно:
				PC<-PC+(2*offset) if n xor v =0

0024xx	BLT		----	переход по меньше:
				PC<-PC+(2*offset) if n xor v =1

0030xx	BGT		----	переход по больше:
				PC<-PC+(2*xx) if z!(n xor v) =0

0034xx	BLE		----	переход по меньше или равно:
				PC<-PC+(2*xx) if z!(n xor v) =1

004Rdd	JSR		----	переход на подпрограмму:      -(SP)<-R,R<-PC,
				PC<-(dst) 

*050dd	CLR(B)		0100	обнуление приемника: (dst)<-0

*051dd	COM(B)		**01	побитовое инвертирование операнда:
				(dst)<-~(dst)

*052dd	INC(B)		**+-	прибавление  1  к  операнду:  (dst)<-(dst)+1;
				v  устанавливается  если   (dst)    превышает
				077777, иначе чистится

*053dd	DEC(B)		**+-	вычитание  1  из  операнда:   (dst)<-(dst)-1;
				v устанавливается, если  (dst)  было  100000,
				иначе чистится.

*054dd	NEG(B)		**++	заменяет  источник  его  дополнением  до    1
				(меняет  знак   числа):    (dst)<-    -(dst);
				v устанавливается, если результат стал 100000
				иначе  чистится;  c  чистится  если   получен
				результат 0, иначе устанавливается

*055dd	ADC(B)		**++	прибавление  к  операнду  бита  переноса (для
				длинной    арифметики):        (dst)<-(dst)+c
				v устанавливается, если (dst) был 077777 и  c
				был установлен, иначе чистится;
				c устанавливается, если (dst) был 177777 и  c
				был установлен, иначе чистится


*056dd	SBC(B)		**++	вычитание  из  операнда  бита  переноса  (для
				длинной   арифметики):   (dst)  <-  (dst) - c
				v=1 если (dst) был  100000,  иначе  чистится;
				c=1 если (dst) был  0,  и  c  был  установлен

*057dd	TST(B)		**00	установка битов условий PSW , соответствующих
				операнду

*060dd	ROR(B)		**++	кольцевой  сдвиг  вправо:  вращает  все  биты
				операнда на  одну позицию вправо; старший бит
				загружается  из бита  переноса,  младший бит, 
				выдвинутый из  операнда,  загружается  в  бит 
				переноса; v=xor(c,n).

*061dd	ROL(B)		**++	кольцевой  сдвиг  влево:   вращает  все  биты
				операнда на  одну позицию влево;  младший бит
				грузится из бита переноса, выдвинутый старший 
				бит загружается в бит переноса; v-xor(c,n).

*062dd	ASR(B)		**++	арифметический   сдвиг   вправо:    одержимое 
				операнда сдвигается  на одну позицию  вправо;
				старший (знаковый) бит  остается  неизменным;
				бит переноса  грузится содержимым выдвинутого 
				бита;  v=xor(c,n). Операцию  можно трактовать 
				как целочисленное деление операнда пополам, с
				остатком, остающимся в бите переноса.

*063dd	ASL(B)		**++	арифметический   сдвиг   влево:    содержимое
				операнда сдвигается  на одну  позицию  влево,
				младший бит  чистится, выдинутый  знакоый бит
				грузится  бит переноса;  v=xor(c,n). Операцию
				можно   рассматривать    как    целочисленное 
				умножение операнда на 2. 

0064nn	MARK		----	чистка стека:
				SP <- PC+2*nn,  PC<-R5,  R5<-(SP)+;  nn-число 
				параметров.

1064ss	MTPS		++++	запись в слово состояния:  PS<-ss, есть не на 
				всех процессорах и не во всех модах.


0065ss	MFPI	mmg	**0-	засылает в стек текущей моды слово  по адресу
				источника    из    пространства    инструкций
				предыдущей моды.

0066dd	MTPI	mmg	**0-	засылает  из  стека  текущей  моды  слово  по 
				адресу приемника  в  пространство  инструкций 
				предыдущей моды.

1065ss	MFPD	mmg	**0-	засылает в стек  текущей моды слово по адресу
				источника из  пространства  данных предыдущей
				моды.  Если диспетчер памяти не  обеспечивает
				отдельное преобразование адресных пространств
				команд и данных,инструкция эквивалентна MFPI.

1066dd	MTPD	mmg	**0-	засылает  из  стека  текущей  моды  слово  по 
				адресу   приемника   в   пространство  данных 
				предыдущей моды.  Если  диспетчер  памяти  не 
				обеспечивает     отдельное     преобразование 
				адресных   пространств   команд   и   данных, 
				инструкция  эквивалентна  MTPI.

1067dd	MFPS			чтение  слова  состояния: (dst)<-PSW; есть не 
				на всех процессорах и не во всех модах.

0067dd	SXT	eis	-+0-	распространение знака:
				(dst)<-0 если бит n очищен
				(dst)<-177777 если бит n установлен
				z устанавливается, если бит n очищен

0070dd	CSM	?

0071::		\

0072nn	TSTSET	?

0073nn	WRTLCK	?

0074::		\
0075::		\
0076::		\
0077::		\


*1ssdd	MOV(B)		**0-	пересылка: (dst)<-(src); MOVB ss,Rn 
				(пересылка  в  регистр  общего   назначения),
				единственная   среди   байтовых   инструкций,
				распространяет    знаковый    бит   источника
				в  старшем  байте  приемника;  при  пересылке
				байта в регистр результат всегда пересылается 
				в   младший   байт  регистра.  Все  остальные 
				байтовые   пересылки   работают  с  байтами в 
				точности как словные со слоавми.

*2ssdd	CMP(B)		***+	сравнение src с dst и установка кодов условий
				PSW: (src) - (dst); 
				v=1, если операнды были разных знаков, и знак 
				приемника был тот  же, что и знак  результата
				( разности   операндов ) ;   иначе   чистится
				c=0, если был  перенос из  старшего  разряда, 
				иначе  устанавливается.
				Операция не изменяет исходных операндов.

*3ssdd	BIT(B)		**0-	проверка  бит  dst  по  маске src и установка 
				кодов условий: (src)&(dst)

*4ssdd	BIC(B)		**0-	очистка бит dst по маске src:
				(dst)<-~(src)&(dst)

*5ssdd	BIS(B)		**0-	установеа бит dst по маске src:
				(dst)<-(src)!(dst)

06ssdd	ADD		****	dst<-src+dst;
				v устанавливается, если оба операнда были
				одного знака, а результат - противоположного,
				иначе - чистится

16ssdd	SUB		***+	dst<-dst-src; 
				v  устанавливается,   если    операнды   были 
				различных  знаков, а знак источника был таким 
				же,  как и знак  результата,  иначе чистится;
				c  чистится,  если был  перенос  из  старшего 
				разряда, иначе - устанавливается


070Rss	MUL	eis	**0+	Содержимое  регистра назначения, и источника,
				рассматриваемые  как  целые  числа в дополни-
				тельном коде перемножаются и запоминаются в 
				регистре - приемнике, и следующем (по номеру) 
				регистре, если номер регистра - приемника 
				четный. Если номер регистра нечетный, запо-
				минается только младшая часть произведения.

071Rss	DIV	eis	++++	32-битовое целое в дополнительном коде, 
				находящееся в регистрах Rn, R(n+1), делится 
				на значение операнда - источника. Деление 
				будет произедено так, что остаток будет 
				одного знака с делимым. Номер регистра должен 
				быть четным.
				n устанавливается, если результат 
				отрицателен, иначе чистится; z 
				устанавлиается, если результат нулевой, иначе 
				чистится; v устанавливается, если источник 
				(делитель) равен нулю, либо если значение 
				регистра по модулю больше абсолютной величины 
				делителя: в этом случае деление не 
				выполняется,поскольку результат ыйдет за 
				разрядную сетку. c устаналиается, если 
				делимое рано нулю, иначе очищается.

072Rss	ASH	eis	**++	Содержимое регистра сдигается вправо или 
				влево на число позиций,указанное в операнде - 
				источнике. Счетчиком позиций являются 6 
				младших бит источника. Отрицательное значение 
				счетчика сдвига означает сдвиг вправо, 
				положительное - влево. При правом сдвиге 
				распространяется старший бит, при левом - 
				младший грузится нулем. v устанавливается, 
				когда знак регистра менялся во время 
				операции, иначе чистится; c загружается 
				последним битом, выдвинутым из регистра. 

073Rss	ASHC	eis	**++	Содержимое регистра, и регистра с номером, 
				полученным установкой младшего бита в номере 
				указанного регистра, рассмаиривается как 

				одно 32 - битовое слово, причем в регистре с 
				большим номером содержатся младшие биты, а  
				регистре с меньшим - старшие, сдигается лево 
				или вправо на число позиций, указанное  
				счетчике сдвига. Счетчиком сдвига являются 
				младшие 6 бит операнда - источника. 
				Отрицательное значение счетчика вызывает 
				сдвиг вправо, положительное - влево. Если 
				номер регистра - приемника нечетный, правый 
				сдвиг становится вращением. 16-разрядное 
				слово вращается вправо на число позиий, 
				указанное в счетчике сдвига. При правом 
				сдвиге распространяется старший бит, при 
				левом сдвиге младший бит грузится нулем.
				v устанавливается, если при сдвиге изменялся 
				знак операнда, иначе чистится; c загружается 
				последним выдвинутым из 32-битового операнда 
				битом.

074Rdd	XOR	eis	**0-	исключающее 'или': (dst)<- R xor (dst)

07500R	FADD	fis	**00	initial state:
				R=>	operand B bits 16-31
					operand B bits 0-15
					operand A bits 16-31
				(R)+6=>	operand A bits 0-15
				After operation floating point stack
				looks:
				R=>
					operand B bits 16-31
					operand B bits 0-15
					result bits 16-31
					result bits 0-15
				result=A+B

07501R	FSUB	fis	**00	initial state:
				R=>	operand B bits 16-31
					operand B bits 0-15
					operand A bits 16-31
				(R)+6=>	operand A bits 0-15
				After operation floating point stack

				looks:
				R=>	operand B bits 16-31
					operand B bits 0-15
					result bits 16-31

					result bits 0-15
				result=A-B

07502R	FMUL	fis	**00	initial state:
				R=>	operand B bits 16-31
					operand B bits 0-15
					operand A bits 16-31
				(R)+6=>	operand A bits 0-15
				After operation floating point stack
				looks:
				R=>	operand B bits 16-31
					operand B bits
					result bits 16-31
					result bits 0-15
				result=A*B
				if the result <2E-128 then the result 
				is treated as zero.

07503R	FDIV	fis	**00	initial state:
				R=>	operand B bits 16-31
					operand B bits 0-15
					operand A bits 16-31
				(R)+6=>	operand A bits 0-15
				After operation floating point stack
				looks:
				R=>	operand B bits
					operand B bits
					result bits 16-31
					result bits 0-15
				result=A/B
				if the result <2E-128 then the result 
				is treated as zero.

07504:		\
07505:		\
07506:		\

07507:		\

076020	L2D0	cis

076021	L2D1	cis

076022	L2D2	cis

076023	L2D3	cis

076024	L2D4	cis

076025	L2D5	cis

076026	L2D6	cis

076027	L2D7	cis

076030	MOVC	cis

076130	MOVCI	cis

076031	MOVRC	cis

076131	MOVRCI	cis

076032	MOVTC	cis

076132	MOVTCI	cis

076033		\
076133		\
076034		\
076134		\
076035		\
076135		\
076036		\
076136		\
076037		\
076137		\


076040	LOCC	cis

076140	LOCCI	cis

076041	SKPC	cis

076141	SKPCI	cis

076042	SCANC	cis

076142	SCANCI	cis

076043	SPANC	cis

076143	SPANCI	cis

076044	CMPC	cis

076144	CMPCI	cis

076045	MATC	cis

076145	MATCI	cis

076046		\
076146		\
076047		\
076147		\

076050	ADDN	cis

076150	ADDNI	cis

076051	SUBN	cis

076151	SUBNI	cis

076052	CMPN	cis

076152	CMPNI	cis


076053	CVTNL	cis

076153	CVTNLI	cis

076054	CVTPN	cis

076154	CVTPNI	cis

076055	CVTNP	cis

076155	CVTNPI	cis

076056	ASHN	cis

076156	ASHNI	cis

076057	CVTLN	cis

076157	CVTLNI	cis

076060	L3D0	cis

076061	L3D1	cis

076062	L3D2	cis

076063	L3D3	cis

076064	L3D4	cis

076065	L3D5	cis

076066	L3D6	cis

076067	L3D7	cis

076070	ADDP	cis

076170	ADDPI	cis

076071	SUBP	cis


076171	SUBPI	cis

076072	CMPP	cis

076172	CMPPI	cis

076073	CVTPL	cis

076173	CVTPLI	cis

076074	MULP	cis

076174	MULPI	cis

076075	DIVP	cis

076175	DIVPI	cis

076076	ASHP	cis

076176	ASHPI	cis

076077	CVTLP	cis

076177	CVTLPI	cis

0762::		\
0763::		\
0764::		\
0765::		\

076600	MED6X	cis?

076601	MED74C	cis?

076602		\
076603		\
076604		\
076605		\
076606		\

076607		\
07661:		\
07662:		\
07663:		\
07664:		\
07665:		\
07666:		\

077Rnn	SOB	eis	----	R<-R-1; если не 0, то PC<- PC-2*offset

1000xx	BPL		----	переход, если плюс:
				PC<-PC+(2*offset) if n=0

1004xx	BMI		----	переход,если минус:
				PC<-PC+(2*offset) if n=1

1010xx	BHI		----	переход, если больше:
				PC<-PC+(2*offset) if c=0 & z=0

1014xx	BLOS		----	переход,если меньше или равно:
				PC<-PC+(2*offset) if c!z=1

1020xx	BVC		----	переход,если нет переполнения:
				PC<-PC+(2*offset) if v=0

1024xx	BVS		----	переход,если переполнение:
				PC<-PC+(2*offset) if v=1

1030xx	BCC		----	переход, если не было переноса:
1030xx	BHIS
				PC<-PC+(2*offset) if c=0

1034xx	BCS		----	переход,если был перенос:
1034xx	BLO
				PC<-PC+(2*offset) if c=1

1040::	EMT		++++	-(SP)<-PSW; -(SP)<-PC; PC<-(30); PSW<-(32)
1041::	EMT			n,z,v,c: грузятся из вектора прерывания
1042::	EMT
1043::	EMT


1044::	TRAP		++++	-(SP)<-PSW; -(SP)<-PC; PC<-(34); PSW<-(36)
1045::	TRAP			n,z,v,c: грузятся из вектора прерывания
1046::	TRAP
1047::	TRAP

107:::		\

code	name	       fpp(cc)	description
		      F(NZVC)

170000	CFCC	fpu

170001	SETF	fpu

170002	SETI	fpu

170003	LDUB	fpu

170004	LDSC	fpu

170005	STA0	fpu

170006	STB0	fpu

170007	STQ0	fpu

170010		\

170011	SETD	fpu

170012	SETL	fpu

170013		\

170014		\

170015		\

170016		\

170017		\


1701SS	LDFPS	fpu

1702DD	STFPS	fpu

1703DD	STST	fpu

1704DD	CLRD	fpu
1704DD	CLRF	fpu

1705SS	TSTD	fpu
1705SS	TSTF	fpu

1706DD	ABSD	fpu
1706DD	ABSF	fpu

1707DD	NEGD	fpu
1707DD	NEGF	fpu

1710DD	MULD	fpu
1710DD	MULF	fpu

1714DD	MODD	fpu
1714DD	MODF	fpu

1720SDD	ADDD	fpu	***0	SUM=(AC)+(FSRC): if underflow occurs and FIU 
1720SDD	ADDF	fpu		is not enabled, AC<-exact 0
				if overflow occurs and FIV is not enabled,
				AC<-exact 0 on FP11C
				for all other cases, AC<-SUM
				The addition is carried out in single or 
				double precision and is rounded or chopped
				in accordance with the values of the FD and 
				FT bits in the FPS register. The result is 
				stored in AC except for:
				oerflow with interrupt disabled on the FP11C
				underflow with interrupt disabled.
				For these exceptional cases, an exact 0 is
				stored in AC.
				If FIVU is enabled, trap on -0 in FSRC
				occurs before execution.

				If overflow or underflow occurs and if the
				corresponding interrupt is enabled, the trap 
				occurs with the faulty result in AC. The 
				fractional parts are correctly stored.
				The exponent part is too large by 400 octal
				for underflow, except for the special case
				of 0, which is correct. If no errors occures,
				then for oppositely signed operands with
				exponent differences of 0 or 1, the answer
				returned is exact if a loss of significance
				of one or more bits occurs. Note that these
				are the only cases for which loss of 
				significance of more than one bit can occur.
				For all other cases the result is inexact 
				with error bounds of
				1 LSB in chopping mode with either single or 
				double precision.
				1/2 LSB in rounding mode with single 
				precision.
				9/16 LSB in rounding mode with double 
				precision.
				The undefined variable -0 can occur only in 
				conjunction with overflow or underflow.
				It will be stored in AC only if the 
				corresponding interrupt is enabled or, for 
				the FP11B, on overflow even if the overflow
				interrupt is not enabled.

1724SDD	LDD	fpu	**00	AC<-(FSRC)
1724SDD	LDF	fpu		load single or double precision number
				into accumulator. If FIVU is enabled,
				trap on -0g mode with single 
				precision.
				9/16 LSB in rounding mode with double 
				precision.
				The undefined variable -0 can occur only in 
				conjunction with overflow or underflow.
				It will be stored in AC only if the 
				corresponding interrupt is enabled or, for 
				the FP11B, on overflow even if the overflow
				interrupt is not enabled.

1724SDD	LDD	fpu	**00	AC<-(FSRC)
1724SDD	LDF	fpu		load single or double precision number
				into accumulator. If FIVU is enabled,
				trap on -0r.
				The result is stored in AC except for:
				  Overflow with interrupt disabled on the 
				  FP11C.
				  Underflow with interrupt disabled.
				For these exceptional cases, an exact 0 is 
				stored in AC.
				If FIUV is enabled, trap on -0 in FSRC occurs
				before execution. If overflow or underflow 
				occurs and if the corresponding interrupt is 
				enabled, the trap occurs with the faulty 
				results in AC. The fractional parts are 
				correctly stored. The exponent part is too 
				small by 400 octal for overflow. It is too 
				large by 400 octal for underflow, except for
				the special case of 0, which is correct.
				Errors due to overflow and underflow are 
				described above. If neither occurs, then: 
				For like-signed operands with exponent 

1734SDD	CMPD	fpu
1734SDD	CMPF	fpu

1740SDD	STD	fpu	----	FDST<-(AC): store single or double number
1740SDD	STF	fpu		from accumulator.

1744SDD	DIVD	fpu
1744SDD	DIVF	fpu

1750SDD	STEXP	fpu

1754SDD	STCDI	fpu
1754SDD	STCDL	fpu
1754SDD	STCFI	fpu
1754SDD	STCFL	fpu

1760SDD	STCDF	fpu
1760SDD	STCFD	fpu

1764SDD	LDEXP	fpu


1770SDD	LDCID	fpu
1770SDD	LDCIF	fpu
1770SDD	LDCLD	fpu
1770SDD	LDCLF	fpu

1774SDD	LDCFD	fpu
1774SDD	LDCDF	fpu
